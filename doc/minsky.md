# extended Marvin Minsky frame concept {#minsky}

### Марвин Минский
## Фреймы для представления знаний

* https://royallib.com/read/minskiy_marvin/freymi_dlya_predstavleniya_znaniy.html#0
* https://ponyatov.quora.com/Minsky-Frames-Database-metaL (см. видео в начале)

Для представления (мета)программ и их обработки в процессе генерации кода
используется расширенное представление фреймов Минского (как базовый класс).
Оригинальные фреймы не имели очень важного для метапрограммирования функционала:
способность хранить упорядоченные объекты. Эта фича необходима для представления
программ, в качестве примера см. деревья разбора/AST и реализацию атрибутных
грамматик.

С другой стороны, фреймы имеют практически полное соответстивие объектной
парадигме, в т.ч. объектам Python. И если мы попытаемся описать дерево программы
через граф питоновских объектов, мы сталкиваемся с необходимостью вводить
упорядоченные контейнеры, например для хранения операндов в выражении деления.

Для некоторой универсализации, 
* отделения логики фреймов от логики работы объектной системы в Python,
* возможности реализации на низкоуровневых языках с жесткой типизацией,
  AOT-компиляцией и соответственно невозможностью произвольно менять структуру
  класса или единичного объекта в рантайме (C++, Java)
* добавления некоторых фич характерных для функциональных и логических языков 
  программирования (унификация/backtracking и структурный pattern matching),

было выбрано расширение концепта фрейма, предложенного Марвином Мински,
добавлением функционала упорядоченного контейнера `nest[]`, позволяющего
не только хранить `attr{}`ибуты (слоты),
но и любые элементы данных в явно заданном порядке.

	class Frame:
    	def __init__(self,V):
        	self.type  = self.__class__.__name__.lower()
        	self.value = V
        	self.attr  = {}
        	self.nest  = []

	print Frame('hello')

	<frame:hello>


Также в большинстве случаев у нас есть необходимость хранить для любого
элемента данных два поля:
* `type` <br>
явно указывающий на тип фрейма. Мы принципиально не можем оперировать
двумя фреймами в выражении типа `<string:> + <number:>` без их приведения к
одному типу, причем это приведение часто зависит от контекста, в каком именно
смысле мы это выражение используем (привет долбанутый JavaScript)
* `value` <br>
атомарное значение, хранимое в типе языка реализации (Python): нам нужно
именовать объекты, хранить значение строк и числовых данных, поэтому также
необходимо подкласс фреймов для представления таких значений-примитивов.
  
(*) имена type/value фиксированы требованиями библиотеки PLY, если вы захотите использовать ее для создания собтвенного языка метапрограммирования или CLI
вместо Python
